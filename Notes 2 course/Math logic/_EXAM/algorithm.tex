\chapter{Теория алгоритмов}

Один из способов задания конструктивных объектов "--- формулы Бэкуса.

\begin{definition}
	\emph{Формулы Бэкуса} имеют вид

	<понятие> $ \Coloneq $ <понятие\textsubscript1> | <понятие\textsubscript2> | <понятие\textsubscript i><понятие\textsubscript j> | \dots
\end{definition}

\section{Рекурсивные функции}

\begin{definition}
	\emph{Простейшими} называются функции натурального аргумента, определяемые равенствами
	$$ S(x) = x + 1, \qquad O(x) = 0, \qquad I_n^m(x_1, \dots, x_n) = x_m $$
\end{definition}

\begin{definition}
	Функция $ f $ от $ n + 1 $ переменных получена их функции $ g $ от $ n $ переменных и функции $ h $ от $ n + 2 $ переменных с помощью \emph{оператора примитивной рекурсии}, если
	$$
	\begin{cases}
		f(x_1, \dots, x_n, 0) = g(x_1, \dots, x_n) \\
		f(x_1, \dots, x_n, y + 1) = h(x_1, \dots, x_n, y, f(x_1, \dots, x_n, y))
	\end{cases} $$
\end{definition}

\begin{definition}
	\emph{Оператор неограниченной минимизации} $ \mu $ определяется как
	$$ g(x_1, \dots, x_n) = \mu~y \set{f(x_1, \dots, x_n, y) = 0} $$
	(наименьшее $ y $, для которого $ f(x_1, \dots, x_n, y) = 0 $)
\end{definition}

\begin{definition}
	\emph{Оператор ограниченной минимизации} $ \mu_{\le z} $ определяется как
	$$ g(x_1, \dots, x_n, z) = \mu~y_{\le z} \set{f(x_1, \dots, x_n, y) = 0} $$
	(наименьшее $ y $, не превосходящее $ z $ и для которого $ f(x_1, \dots, x_n, y) = 0 $, иначе 0)
\end{definition}

\begin{definition}
	Функция называется \emph{частично рекурсивной}, если она может быть получена из простейших с помощью применения операторов подстановки, примитивной рекурсии и ограниченной минимизации.
\end{definition}

\begin{definition}
	\emph{Обобщённый оператор минимизации} определяется как
	$$ \mu^*~y \set{f(\ol x, y) = 0} =
	\begin{cases}
		\mu~y \set{f(\ol x, y) = 0}, \quad \text{если такой $ y $ существует}, \\
		0 \qquad \text{ иначе}
	\end{cases} $$
\end{definition}

\begin{definition}
	Функция называется \emph{общерекурсивной}, если она может быть получена из простейших с помощью применения операторов подстановки, примитивной рекурсии и обобщённой минимизации.
\end{definition}

\begin{undefthm}{Тезис Чёрча}
	Всякая интуитивно вычислимая функция является общерекурсивной.
\end{undefthm}

\section{Машины Тьюринга}

\begin{definition}
	\emph{Машина Тьюринга} задаётся тройкой $ \braket{A, Q, P} $, где
	\begin{itemize}
		\item $ A = \set{a_1, \dots, a_n} $ "--- внешний алфавит (содержащий пустой символ, который будем обозначать *);
		\item $ Q = \set{q_0, q_1, \dots, q_k} $ "--- внутренний алфавит, в котором выделена начальное и заключительное состояния $ q_1 $ и $ q_0 $;
		\item $ P $ "--- программа
	\end{itemize}
\end{definition}

\begin{definition}
	\emph{Команда машины Тьюринга} имеет вид
	$$ q_ra_i \to q_tSa_j, $$
	где $ i, j = 1, \dots, n, \quad r = 1, \dots, k, \quad t = 0, 1, \dots, k, \quad S \in {L, R, \text\textunderscore} $.
\end{definition}

\begin{definition}
	Команды называются \emph{согласованными}, если они имеют различные левые части, или полностью совпадают.
\end{definition}

\begin{definition}
	\emph{Программой машины Тьюринга} называется конечное непустое множество согласованных команд.
\end{definition}

\begin{definition}
	\emph{Конфигурацией машины Тьюринга} называется слово вида
	$$ b_1\dots b{p - 1} \bm{q_r} b_p \dots b_l, $$
	где
	\begin{itemize}
		\item $ b_1, \dots, b_l $ "--- слово в алфавите $ A $, записанное на ленте;
		\item слева и справа от этого слова на ленте находятся только пустые символы;
		\item машина находится в состоянии $ q_r $ и обозревает $ p $-й символ этого слова;
		\item на концах конфигурации находится не более чем по одному пустому символу;
	\end{itemize}
\end{definition}

\begin{definition}
	\emph{Протоколом работы машины Тьюринга} называется последовательность конфигураций, первая из которых является начальной, а каждая следующая получена из предыдущей одной из команд.
\end{definition}

Машина Тьюринга заканчивает работу над данными $ X $, если она пришла в состояние $ q_0 $, или ни одна из команд не может быть применена к текущей конфигурации.

\begin{undefthm}{Тезис Тьюринга"--~Чёрча.}
	Всякая интуитивно вычислимая функция может быть вычислена на машине Тьюринга.
\end{undefthm}

\begin{lemma}
	По всякой машине Тьюринга $ M $, которая по данным $ X $ в алфавите $ A $ вычисляет значение функции $ f(X) $, можно построить машину Тьюринга $ M_1 $, которая по данным $ X $ вычисляет значение функции $ f(X) $ и заканчивает работу в конфигурации $ q_0~f(X) $.
\end{lemma}

\begin{eproof}
	\item Пометим начало слова символом, не входящим в алфавит $ A $ (например, символом \#) и вернёмся в начало исходных данных.
		$$ q_1 a_i \to q_1La_i $$
		$$ q_1* \to q_2R\# $$

	\item В программе машины $ M $ каждое вхождение состояния $ q_i $ заменяем на $ q_{i + 1} $.

	\item Возможны два случая завершения работы программы:
		\begin{itemize}
			\item Машина Тьюринга завершила работу в конфигурации $ \#Y'q_0Y'' $, где $ Y'Y'' $ совпадает с $ f(X) $.

				Заменяем в тексте программы состояние $ q_0 $ на $ q_{k + 2} $ и добавляем команды
			$$ q_{k + 2}a_i \to q_{k + 2}La_i, \qquad a_i \in A $$
			$$ q_{k + 2}\# \to q_0 R* $$

		\item Машина Тьюринга завершила работу в конфигурации $ \#Y'q_ta_iY''' $, где $ Y'a_iY''' $ совпадает с $ f(X) $ и в программе отсутствует команда с левой частью $ q_ta_i $.

			Для каждого состояния $ q_t $ и каждого символа $ a_i $ из алфавита, для которых в программе отсутствует команда с левой частью $ q_ta_i $, добавляем команду
			$$ q_ta_i \to q_{k + 2}La_i $$
			и команды, указанные в предыдущем пункте.
	\end{itemize}
\end{eproof}

\begin{theorem}
	Пусть машина Тьюринга $ M_1 $ по данным $ X $ в алфавите $ A_1 $ вычисляет значение функции $ g(X) $ в алфавите $ A_2 $, машина Тьюринга $ M_2 $ по данным $ Y $ в алфавите $ A_2 $ вычисляет значение функции $ f(Y) $.

	Тогда существует машина Тьюринга $ M_3 $, которая по данным $ X $ вычисляет значение функции $ f \bigl( g(X) \bigr) $.
\end{theorem}

\begin{proof}
	Пусть $ M_i $ ($ i = 1,2 $) имеет программу $ P_i $ и использует состояния $ \set{q_0, q_1, \dots, q_{k_i}} $. \\
	В соответствии с леммой можно считать, что $ M_1 $ заканчивает работу в конфигурации $ q_0g(X) $.

	В программе $ P_1 $ состояние $ q_0 $ заменяем на $ q_{k_1 + 1} $, получаем программу $ P_1' $.

	В программе $ P_2 $ состояния $ q_i $ ($ i = 1, \dots, k_2 $) заменяем на $ q_{k_1 + i} $, получаем программу $ P_2' $.

	Машина с программой $ P_1' \cup P_2' $ вычисляет $ f \bigl( g(X) \bigr) $.
\end{proof}

Аналогичную теорему можно доказать и для функций нескольких аргументов.
Однако при её доказательстве требуется лемма, которая будет приведена здесь без доказательства.

\begin{definition}
	Машина Тьюринга называется машиной Тьюринга с односторонне-ограниченной лентой, если она не использует ячейки, расположенные левее ячейки с первым символов исходных данных (левосторонне-ограниченная), или расположенные правее ячейки с последним символом исходных данных (правосторонне-ограниченная).
\end{definition}

\begin{lemma}
	По всякой машине Тьюринга можно построить машину Тьюринга с односторонне-ограничен"-ной лентой, у которой на любых исходных данных результат её работу совпадает с результатом работы $ M $.
\end{lemma}

\begin{theorem}
	Пусть машина Тьюринга $ M_1 $ по данным $ X_1, \dots, X_i, \dots, X_n $ в алфавите $ A_1 $ вычисляет значение функции $ f(X_1, \dots, X_i, \dots, X_n) $ в алфавите $ A_2 $, машина Тьюринга $ M_2 $ по данным $ Y_1, \dots, Y_m $ в алфавите $ A_2 $ вычисляет значение функции $ g(Y_1, \dots, Y_m) $.

	Тогда существует машина Тьюринга $ M_3 $, которая по данным $ X_1, \dots, X_{i - 1}, X_{i + 1}, \dots, X_n, Y_1, \dots, Y_m $ вычисляет значение функции $ f \bigl( X_1, \dots, X_{i - 1}, g(Y_1, \dots, Y_m), X_{i + 1}, \dots, X_n \bigr) $.
\end{theorem}

\begin{eproof}
	\item По машине $ M_2 $ строим левосторонне-ограниченную машину $ M_3 $ с программой $ P_3 $.

	\item Машина с программой $ P_0 $ с состояниями $ q_0, q_1, \dots, q_{k_0} $ отмечает место между $ X_{i - 1} $ и $ X_{i + 1} $ и подводит головку к первому символу данных $ Y_1, \dots, Y_m $.
		Заменив $ q_0 $ на $ q_{k_0 + 1} $ получаем программу $ P_0' $.

	\item В программе $ P_3 $ заменяем $ q_i $ на $ q_{k_0 + i} $ при $ i \ne 0 $, а $ q_0 $ на $ q_{k_0 + k_3 + 1} $ и получаем программу $ P_3' $.

	\item Машина с программой $ P_4 $ с состояниями $ q_0, q_1, \dots, q_{k_4} $ вставляет результат работы программы $ P_3' $ между $ X_{i - 1} $ и $ X_{i + 1} $ и подводит головку к первому символу, записанному на ленте.
		Заменив $ q_i $ на $ q_{k_0 + k_3 + i} $ при $ i \ne 0 $, а $ q_0 $ на $ q_{k_0 + k_3k_4 + 1} $ получаем программу $ P_4' $.

	\item В программе $ P_1 $ для машины $ M_1 $ заменяем $ q_i $ при $ i \ne 0 $ на $ q_{k_0 + k_3 + k_4 + i} $ и получаем программу $ P_1' $.
	
		Машина с программой $ P-0' \cup P_3' \cup P_4' \cup P_1' $ вычисляет $ f \bigl( X_1, \dots, X_{i - 1}, g(Y_1, \dots, Y_m), X_{i + 1}, \dots, X_n \bigr) $
\end{eproof}

\subsection{Многоленточные МТ}

\begin{definition}
	Команда $ k $-ленточной машины Тьюринга имеет вид
	$$ q_r
	\begin{pmatrix}
		a_{i_1} \\
		\vdots \\
		a_{i_k}
	\end{pmatrix} \to q_t
	\begin{pmatrix}
		S_1 \\
		\vdots \\
		S_k
	\end{pmatrix}
	\begin{pmatrix}
		a_{j_1} \\
		\vdots \\
		a_{j_k}
	\end{pmatrix}, $$
	где $ S_1, \dots, S_k \in \set{L, R, \text\textunderscore} $.
\end{definition}

Обычно предполагается, что 1-я лента "--- это входная лента для записи исходных данных, k-я лента "--- это выходная лента для записи результата, остальные ленты "--- это рабочие ленты.

\begin{theorem}
	По всякой $ k $-ленточной машине Тьюринга MTk, заканчивающей работу с исходными данными $ X $ за $ t $ шагов, можно построить одноленточную машину Тьюринга $ MT1 $, результат работы которой с исходными данными $ X $ совпадает с результатом работы и число шагов которой составляет $ O(t^2) $.
\end{theorem}

\begin{proof}
	Пусть длина записи исходных данных равна $ n $, причём $ n \le t $.
	Будем считать, что первая лента входная, а последняя "--- выходная.

	На $ i $-м шаге $ (i = 1, \dots, t) $ длина записи на $ j $-ой ленте $ MTk $ ($ j = 2, \dots, k $) может увеличиться не более чем на единицу (\it стать равной $ i $), причём запись нового символа может происходить как в середине слова, так и на одном его концов.
	При этом содержимое лент имеет вид
	$$
	\begin{pmatrix}
		X \\
		X_i^2 \\
		\vdots \\
		X_i^k
	\end{pmatrix} $$
	Конфигурация моделирующей машины MT1 в этот момент имеет вид
	$$ X*q_lX_i^2* \dots *X_i^k $$
	при некотором $ l $.

	Для моделирования $ i $-го шага MTk машина MT1 должна для каждого $ (j = 2, \dots, k) $
	\begin{itemize}
		\item сдвинуть головку на символ, обозреваемый MTk на $ j $-ой ленте (не более, чем $ \| X_i^{j - 1}\| + \|X_i^j\| $ шагов);
		\item произвести действие, которое MTk производит со словом $ X_i^j $ (1 шаг);
		\item в случае необходимости переместить всё содержимое ленты правее положения головки на одну ячейку вправо (не более, чем $ 4 \sum_{j' = j}^k \|X_i^{j'}\| $);
		\item вернуться в исходное положение (не более, чем $ \sum_{j' = j}^k \|X_i^{j'}\| $ шагов);
		\item вернуться в исходное положение (не более, чем $ \sum{j' = j}^k \|X_i^{j'}\| $ шагов).
	\end{itemize}
	Всего при моделировании действия MTk с одним символом на $ i $-ом шаге MT1 совершает не более
	\begin{multline*}
		\sum_{j = 2}^k \Bigl( \|X_i^{j - 1}\| + \|X_i^j\| + 1 + 4 \sum_{j' = j}^k \|X_i^{j'}\| + \sum_{j' = j}^k \|X_i^{j'}\| \Bigr) \le \sum_{j = 2}^k \Bigl( i + i + 1 + 5 \sum_{j' = j}^k i \Bigr) = \sum_{j = 2}^k \bigl( 5 (k - j) i + 2i + 1 \bigr) = \\
		= \frac12 \cdot 5i(k - 1)(k - 2) + 2i(k - 1) + 2(k - 1) = \frac3 i (k - 1)(3k - 4) + 2(k - 1)
	\end{multline*}
	Просуммировав полученное выражение по $ i = 1, \dots, t $ имеем
	$$ \frac32 \sum_{i = 1}^t i \bigl( (k - 1)(3k - 4) + 2(k - 1) \bigr) = \frac32 (k - 1)(3k - 4) \frac{t(t - 1)}2 + 2(k - 1) = O(k^2t^2) $$
	Так как $ k $ является константой, то получили $ O(t^2) $.
\end{proof}

\subsubsection{Многоголовчатые МТ}

\begin{definition}
	\emph{Команда} $ m $-головчатой машины Тьюринга имеет вид
	$$ q_r(a_{i_1}, \dots, a_{i_m}) \to q_t(A_1, \dots, S_m)(a_{j_1}, \dots, a_{j_m}), $$
	где $ S_1, \dots, S_m \in \set{L, R, \text\textunderscore} $.
\end{definition}

\subsubsection{Недетерминированные МТ}

\begin{lemma}
	Если недетерминированная машина Тьюринга, проверяющая предикат $ \exists Y~P(X, Y) $ заканчивает работу с исходными данными $ X $ за $ t $ шагов, то длина ``претендента`` $ Y $ не превосходит $ t $.
\end{lemma}

\begin{proof}
	Утверждение леммы следует из того, что длина записи слова не может быть больше, чем число шагов, затраченных на его выписывание.
\end{proof}

\begin{lemma}
	Если недетерминированная машина Тьюринга, проверяющая предикат $ \exists Y~P(X, Y) $ заканчивает работу с исходными данными $ X $ за $ t $ шагов, то количество ``претендентов'' $ Y $ не превосходит $ 2^{O(t)} $.
\end{lemma}

\begin{proof}
	Пусть $ A = \set{a_1, \dots, a_k} $ "--- внешний алфавит недетерминированной машины Тьюринга.
	Количество ``претендентов`` $ m $ не превосходит количества слов в этом алфавите, длина которых не превосходит $ t $, \ie
	$$ m \le \sum_{i = 0}^t k^i = \frac{k^{t + 1} - 1}{k - 1} \le k^{t + 1} = 2^{(t + 1)\log k} = 2^{O(t)} $$
\end{proof}

\begin{theorem}\label{th:n_to_d}
	По всякой недетерминированной машине Тьюринга, проверяющей предикат $ \exists Y~P(X, Y) $ и заканчивающей работу с исходными данными $ X $ за $ t $ шагов, можно построить одноленточную машину Тьюринга, результат работы которой с исходными данными $ X $ совпадает с результатом работы исходной и число шагов которой составляет $ 2^{O(t)} $.
\end{theorem}

\begin{proof}
	Работу детерминированной машины Тьюринга организуем следующим образом:
	\begin{enumerate}
		\item порождаем $ Y_1 $, проверяем $ P(X, Y_1) \qquad \le t $ шагов;
		\item порождаем $ Y_m $, проверяем $ P(X, Y_m) \qquad \le t $ шагов.
	\end{enumerate}
	Общее число шагов не превосходит $ m \cdot t \le t \cdot 2^{O(t)} = 2^{O(t + \log t)} = 2^{O(t)} $.
\end{proof}

\begin{implication}[из доказательства]
	Если недетерминированная машина Тьюринга, проверяющая предикат $ \exists Y~P(X, Y) $ заканчивает работу с исходными данными $ X $ за $ t $ шагов, то можно построить одноленточную машину Тьюринга, результат работы которой с исходными данными $ X $ совпадает с результатом работы исходной и число используемых ячеек которой не превосходит $ t $.
\end{implication}

\begin{proof}
	Для доказательства этого следствия достаточно в доказательстве теоремы после каждой проверки $ P(X, Y_m) $ возвращать головку машины Тьюринга в исхожное положение.
	При этом число шагов может увеличиться вдвое.
\end{proof}

\section{Нормальные алгоритмы Маркова}

\begin{definition}
	\emph{Марковской подстановкой} называется операция над словами $ P \to Q $, состоящая в следующем.
	В обрабатываемом слове $ R $ находят первое вхождение слова $ P $ (если таковое имеется) и, не изменяя остальных частей слова $ R $, это вхождение заменяют в нём словом $ Q $.
	Полученное слово называется результатом применения марковской подстановки к слову $ R $.
	Если же вхождения $ P $ в слово $ R $ нет, то считается, что марковская подстановка $ P \to Q $ не применима к слову $ R $.

	Марковская подстановка вида $ P \to \cdot Q $ называется \emph{заключительной}.
\end{definition}

\begin{definition}
	Упорядоченный конечный список подстановок
	$$
	\begin{cases}
		P_1 \to [\cdot]Q_1, \\
		\dots \\
		P_r \to [\cdot]Q_r,
	\end{cases} $$
	в алфавите $ A $ называется \emph{записью} нормального алгоритма в $ A $.
\end{definition}

\begin{undefthm}{Принцип нормализации Маркова}
	Всякая интуитивно вычислимая функция может быть вычислена с помощью нормального алгоритма.
\end{undefthm}

\begin{theorem}
	Следующие классы функции, заданных на натуральных числах и принимающих натуральные значения, совпадают:
	\begin{enumerate}
		\item класс всех функций, вычислимых по Тьюрингу;
		\item класс всех частично рекурсивных функций;
		\item класс всех нормально вычислимых функций.
	\end{enumerate}
\end{theorem}

\section{Код алгоритма. Применимость алгоритма к данным}

\begin{definition}
	Алгоритм $ A $ называется \emph{применимым к данным} $ P $, если он заканчивает работу над данными $ P $ за конечное число шагов.
\end{definition}

\begin{notation}
	!A(P)
\end{notation}

\begin{definition}
	Алгоритм $ A $ называется \emph{самоприменимым}, если он применим к собственному коду.
\end{definition}

\begin{notation}
	!A(\#A)
\end{notation}

\begin{definition}
	Алгоритм $ A $ называется \emph{самоаннулируемым}, если результат его применения к собственному коду равен пустому слову (нулю).
\end{definition}

\begin{notation}
	A(\#A) = $ \Lambda $
\end{notation}

\begin{definition}
	Алгоритм $ U $ называется \emph{универсальным}, если для любого алгоритма $ A $ и исходных данных $ P $, к которым он применим, $ U $ применим к $ \#A $ и $ P $ и результаты их работы совпадают.
	$$ \forall A~P \Bigl( !A(P) \to !U(\#A, P) \amp U(\#A, P) = A(P) \Bigr) $$
\end{definition}

\begin{definition}
	Алгоритм $ B $ называется \emph{продолжением алгоритма} $ A $ ($ A \sub B $), если для любых исходных данных $ P $, к которым применим алгоритм $ A $, алгоритм $ B $ тоже применим к ним и результаты их работы совпадают.
	$$ \forall P \bigl( !A(P) \to !B(P) \amp A(P) = B(P) \bigr) $$
\end{definition}

\begin{theorem}\label{th:auto_appl}
	Не существует такого алгоритма $ B $, который применим к кодам тех и только тех алгоритмов, которые не являются самоприменимыми.
	$$ \neg \exists B~ \forall A \bigl( !B(\#A) \leftrightarrow \neg !A(\#A) \bigr) $$
\end{theorem}

\begin{proof}
	Предположим, что такой алгоритм $ B_0 $ существует
	$$ \forall A \bigl( !B_0(\#A) \leftrightarrow \neg !A(\#A) \bigr) $$
	Тогда при $ A = B_0 $ верно
	$$ !B_0(\#B_0) \leftrightarrow \neg !B_0(\#B_0), $$
	что невозможно.
\end{proof}

\begin{theorem}\label{th:auto_annul}
	Не существует такого алгоритма $ B $, который равен нулю на кодах тех и только тех алгоритмов, которые не являются самоаннулируемыми.
	$$ \neg B ~ \forall A \bigl( B(\#A) = \Lambda \leftrightarrow A(\#A) \ne \Lambda \bigr) $$
\end{theorem}

\begin{proof}
	Предположим, что такой алгоритм $ B_0 $ существует
	$$ \forall A \bigl( B_0(\#A) = \Lambda \leftrightarrow A(\#A) \ne \Lambda \bigr) $$
	Тогда при $ A = B_0 $ верно
	$$ B_0(\#B_0) = \Lambda \leftrightarrow B_0(\#B_0) \ne \Lambda, $$
	что невозможно.
\end{proof}

\begin{theorem}\label{th:uni}
	Не существует всюду применимого продолжения универсального алгоритма.
\end{theorem}

\begin{proof}
	Предположим, что такой алгоритм $ B_0 $ существует.

	Построим алгоритм $ C $, определяемый равенством $ \forall x \bigl( C(x) = B_0(x, x) \| a_1 \bigr) $, \ie к результату его работы приписан символ $ a_1 $.
	Этот алгоритм всюду применим и следовательно, применим к собственному коду и $ C(\#C) = B_0(\#C, \#C) \| a_1 $.

	Так как $ B_0 $ "--- продолжение универсального алгоритма, то верно, что $ \forall A~P \Bigl( !A(P) \to !B_0(\#A, P) \amp B_0(\#A, P) = A(P) \Bigr) $, в частности, при $ A = C $, $ P = \#C $
	$$ B_0(\#C, \#C) = C(\#C), $$
	что противоречит полученному ранее значению для $ C(\#C) $.
\end{proof}

\section{Массовые проблемы. Алгоритмическая разрешимость и не\tpst{\-}{}разрешимость}

\begin{definition}
	\emph{Массовой проблемой} называется задача вида
	$$ (?x)~\phi(x), $$
	где $ \phi(x) $ "--- формула какого-либо формализованного языка со свободной переменной $ x $.
\end{definition}

\begin{definition}
	Массовая проблема $ (?x)~\phi(x) $ называется \emph{алгоритмически разрешимой}, если существует всюду применимый алгоритм $ B $, равный пустому слову $ \Lambda $ на тех и только тех значениях параметра $ x $, для которых верна формула $ \phi(x) $
	$$ \exists B ~\forall x \bigl( B(x) = \Lambda \leftrightarrow \phi(x) \bigr) $$
\end{definition}

\begin{theorem}
	Массовая проблема самоприменимости алгоритма
	$$ (?A)~!A(\#A) $$
	алгоритмически неразрешима.
\end{theorem}

\begin{proof}
	Предположим, что $ (?A)~!A(\#A) $ алгоритмически разрешима, \ie имеется всюду применимый алгоритм $ B_0 $ такой, что
	$$ \forall A \bigl( B_0(\#A) = \Lambda \leftrightarrow !A(\#A) \bigr) $$
	Построим алгоритм $ C $, который применим к данным $ x $ тогда и только тогда, когда $ B_0(x) \ne \Lambda $.
	Доказательство проведём для машины Тьюринга.

	Пусть $ M_1 $ "--- программа машины Тьюринга, вычисляющей $ B_0 $ и имеющей состояния $ q_0, q_1, \dots, q_{k_1} $.

	Заменим в программе $ M_1 $ состояние $ q_0 $ на $ q_{k_1 + 1} $ и добавим команды
	$$ q_{k_1 + 1}a \to q_0 a, \qquad a \in A, \quad a \ne * $$
	$$ q_{k_1 + 1}* \to q_{k_1 + 2}* $$
	Эта машина Тьюринга остановится, если $ B_0(P) \ne \Lambda $ (\ie $ \neg !A(\#A) $), и головка будет бесконечно стоять на ячейке, в которой записан пустой символ, если $ B_0(P) = \Lambda $ (\ie $ !A(\#A) $).
	Но по \autoref{th:auto_appl} такой машины не существует.
\end{proof}

\begin{theorem}
	Массовая проблема самоаннулируемости алгоритма
	$$ (?A)~!A(\#A) $$
	алгоритмически неразрешима.
\end{theorem}

\begin{proof}
	Предположим, что $ (?A)~A(\#A) = 0 $ алгоритмически разрешима, \ie имеется алгоритм $ B_0 $ так, что
	$$ \forall A \bigl( B_0(\#A) = \Lambda \leftrightarrow A(\#A) = 0 \bigr) $$
	Построим алгоритм $ C $, который равен нулю на тех и только тех данных $ x $, для которых $ B_0(x) \ne 0 $.
	Доказательство проведём для машины Тьюринга.

	Пусть $ M_1 $ "--- программа машины Тьюринга, вычисляющей $ B_0 $ и имеющей состояния $ q_0, q_1, \dots, q_k $ и обрабатывающей слова в алфавите $ \set{a_1, \dots, a_n, *} $.

	Заменим в программе $ M_1 $ состояние $ q_0 $ на $ q_{k_1 + 1} $ и добавим команды
	$$ q_{k + 1}* \to q_0 a_1 $$
	$$ q_{k + 1} a_i \to q_{k + 2} R *, \qquad i \in \set{1, \dots, n} $$
	$$ q_{k + 2} a_i \to q_{k + 2} R *, \qquad i \in \set{1, \dots, n} $$
	$$ q_{k + 2} * \to q_0 * $$
	Эта машина Тьюринга даёт в ответе $ \Lambda $, если $ B_0(P) \ne \Lambda $ (\ie $ A(\#A) = \Lambda $) и непустое значение, если $ B_0(P) = \Lambda $ (\ie $ A(\#A) \ne 0 $).
	Но по \autoref{th:auto_annul} такой машины Тьюринга не существует.
\end{proof}

\begin{theorem}
	Массовая проблема применимости алгоритма к данным алгоритмически неразрешима ни в одной из следующих формулировок
	\begin{enumerate}
		\item $ (?A~P)~!A(P) $;
		\item $ (?A)~!A(P) $;
		\item $ (?P)~!A(P) $.
	\end{enumerate}
\end{theorem}

\begin{remark}
	Во второй и третьей формулировках имеются свободные переменные $ P $ и $ A $ соответственно.
	По ним предполагается квантор существования.

	Из алгоритмической неразрешимости проблемы в третьей формулировке следует алгоритмическая неразрешимость проблемы в первой формулировке.

	Кроме того, если доказана алгоритмическая неразрешимость проблемы в третьей формулировке для конкретного алгоритма, и в качестве данных $ P $ взяты те данные, для которых невозможно определить применимость к ним этого алгоритма, то тем самым будет доказана алгоритмическая неразрешимость проблемы во второй формулировке.
\end{remark}

Поэтому докажем алгоритмическую неразрешимость проблемы в третьей формулировке для универсального алгоритма.

\begin{lemma}
	Массовая проблема применимости универсального алгоритма к данным $ (?P)~!U(P) $ алгоритмически неразрешима.
\end{lemma}

\begin{proof}
	Предположим, что $ (?P)~!U(P) $ алгоритмически разрешима, \ie имеется алгоритм $ B_0 $ такой, что
	$$ \forall P \bigl( B_0(P) = \Lambda \leftrightarrow !U(P) \bigr) $$
	Построим алгоритм $ C $, который для кода любого алгоритма $ A $ и исходных данных $ P $ в качестве ответа выдаёт $ A(P) $, если $ B_0(\#A, P) = \Lambda $, и останавливается иначе.
	Доказательство проведём для машины Тьюринга.

	Пусть $ M_1 $ "--- программа машины Тьюринга, вычисляющей $ B_0 $ и имеющей состояния $ q_0, q_1, \dots q_{k_1} $.
	Без потери общности можно считать, что при работе этой машины головка не сдвигается левее своего начального положения.

	Пусть $ M_2 $ "--- программа машины Тьюринга вычисляющей $ U $ и имеющей состояния $ q_0, q_1, \dots, q_{k_2} $.

	Можно построить машину Тьюринга, которая дублирует входное слово и останавливается в начале его второго экземпляра.
	Пусть эта машина имеет программу $ M_0 $ и имеет состояния $ q_0, q_1, \dots, q_{k_0} $.

	Заменим в программе $ M_0 $ состояние $ q_0 $ на $ q_{k_0 + 1} $, в программе $ M_1 $ состояния $ q_i $ на $ q_{k_0 + i} $ и $ q_0 $ на $ q_{k_0 + k_1 + 1} $ и добавим команды
	$$ q_{k_0 + k_1 + 1} \Lambda \to q_{k_0 + k_1 + 2} L * $$
	$$ q_{k_0 + k_1 + 1} a \to q_0 a, \qquad a \in A, \quad a \ne * $$
	$$ q_{k_0 + k_1 + 2}a \to q_{k_0 + k_1 + 2} L A, \qquad a \in A, \quad a \ne * $$
	$$ q_{k_0 + k_1 + 2}* \to q_{k_0 + k_1 + 3}R $$
	Добавим также программу $ M_2 $, в которой заменим состояния $ q_i $ ($ i \ne 0 $) на $ q_{k_0 + k_1 + 2 + i} $.

	Эта машина Тьюринга является всюду применимым продолжением универсальной машины Тьюринга.
	Но по \autoref{th:uni} такой машины Тьюринга не существует.
\end{proof}

\begin{theorem}
	Массовая проблема проверки общезначимости предикатной формулы алгоритмически неразрешима.
\end{theorem}

\begin{note}
	Обычно говорят, что исчисление предикатов алгоритмически неразрешимо.
\end{note}

\begin{proof}
	Построим по программе $ M $ универсального алгоритма и исходным данным $ P $ предикатную формулу, которая истинна тогда и только тогда, когда универсальный алгоритм применим к данным $ P $.

	Для этого достаточно рассмотреть исходные предикаты
	$$ O(i, k) \iff \text{ ``на $ i $-м шаге машина $ M $ находится в состоянии $ q_k $''} $$
	$$ H(i, k) \iff \text{ ``на $ i $-м шаге машина $ M $ обозревает $ j $-ю ячейку''} $$
	$$ S(i, j, h) \iff \text{ ``на $ i $-м шаге в $ j $-й ячейке записан символ $ a_h $''} $$

	С помощью этих предикатов можно описать весь процесс работы универсального алгоритма над исходными данными.
	Тот факт, что $ !U(P) $ запишется формулой, в посылке импликации которой стоит описание работы $ U $ над $ P $, а в заключении "--- формула $ \exists i~O(i, 0) $.

	Если исчисление предикатов алгоритмически разрешимо, то существует алгоритм, который по каждой такой формуле проверяет, общезначима ли она.
	Тем самым построен алгоритм, проверяющий применимость универсального алгоритма к данным.
\end{proof}

\section{Теория сложности алгоритмов}

\begin{definition}
	Под \emph{вычислительной сложностью} алгоритма понимают функцию, зависящую от длины записи исходных данных и характеризующую
	\begin{itemize}
		\item число шагов работы алгоритма над исходными данными \emph{временная сложность};
		\item объём памяти, необходимой для работы алгоритма над исходными данными (\emph{ёмкостная} или \emph{зональная сложность}).
	\end{itemize}
\end{definition}

\begin{definition}
	\emph{Сложностью} $ S_A(P) $ алгоритма $ A $ при работе над данными $ P $ называется число шагов или объём памяти, затраченные в процессе работы алгоритма $ A $ над данными $ P $.
\end{definition}

\begin{definition}
	\emph{Верхней (нижней) оценкой сложности} алгоритма $ A $ при работе над данными длины $ n $ называется
	$$ S_A^U(n) = \max\limits_{P : \| P \| = n} \set{S_A(P)} $$
	$$ S_A^L(n) = \min\limits_{P : \| P \| = n} \set{S_A(P)} $$
\end{definition}

\begin{definition}
	\emph{Точной верхней оценкой сложности} задачи $ Z $ с исходными данными длины $ n $ называется
	$$ S_Z^U(n) = \min\limits_{A : A \text{ решает } Z} \set{S_A^U(n)} $$
\end{definition}

В качестве следствия \autoref{th:n_to_d} можно доказать следующую теорему.

\begin{theorem}
	Если задача вида $ \exists Y~P(X, Y) $ принадлежит классу \bt{NP}, то существует решающая её одноленточная машина Тьюринга, число шагов которой составляет $ 2^{p(n)} $, где $ p(n) $ "--- полином от длины записи исходных данных $ n = \|X\| $.
\end{theorem}

\subsection{Полиномиальная сводимость и полиномиальная эквивалентность}

\begin{definition}
	Задача $ Z_1 $ вида $ \exists Y~P_1(X, Y) $ при $ X \in D_1 $ \emph{полиномиально сводится} к задаче $ Z_2 $ вида $ \exists Y~P_2(X, Y) $ при $ X \in D_2 $, если существует функция $ f $, отображающая $ D_1 $ в $ D_2 $, такая, что
	\begin{enumerate}
		\item существует машина Тьюринга, вычисляющая функцию $ f $ не более чем за полиномиальное от длины записи исходных данных число шагов ($ f \in \bt{FP} $);
		\item задача $ Z_1 $ имеет решение с исходными данными $ X $ тогда и только тогда, когда задача $ Z_2 $ имеет решение с исходными данными $ f(X) $
			$$ \forall X_{\in D_1} \Bigl( \exists Y~P_1(X, Y) \leftrightarrow \exists Y~P_2 \bigl( f(X), Y \bigr) \Bigr) $$
	\end{enumerate}
\end{definition}

\begin{notation}
	$ Z_1 \propto Z_2 $
\end{notation}

Далее под задачей $ Z_i $ будем подразумевать задачу вида $ \exists Y~P_1(X, Y) $ при $ X \in D_i $.

\begin{lemma}
	Отношение полиномиальной сводимости рефлексивно и транзитивно.
\end{lemma}

\begin{lemma}
	Если $ Z_1 \propto Z_2 $ и $ Z_2 \in \bt P $, то $ Z_1 \in \bt P $.
\end{lemma}

\subsubsection{Пример полиномиальной сводимости}

\begin{problem}[Гамильтонов цикл]
	\bt{Дано:} граф $ G = (V, E) $.

	\bt{Вопрос:} существует ли в $ G $ гамильтонов цикл?
	$$ \exists (v_{i_1}, \dots, v_{i_n})~\Bigl( \set{v_{i_1}, \dots, v_{i_n}} = V \amp \set{v_{i_1}, v_{i_2}} \in E \amp \dots \amp \set{v_{i_n}, v_{i_1}} \in E \Bigr) $$
\end{problem}

\begin{problem}[Коммивояжёр]
	\textbf{Дано:} $ C = \set{c_1, \dots, c_n} $ "--- множество городов, $ d_{ij} \in \Z_+ $ "--- расстояния между $ c_i $ и $ c_j $, $ B \in \Z_+ $.

	\textbf{Вопрос:} существует ли маршрут, проходящий через все города, длина которого меньше $ B $?
	$$ \exists (c_{i_1}, \dots, c_{i_m})~\Bigl(\set{c_{i_1}, \dots, c_{i_m}} = C \amp \sum_{j = 1}^{m - 1} d_{i_j~i_{j + 1}} + d_{i_m~i_1} \le B \Bigr) $$
\end{problem}

Покажем, что \bt{ГЦ} $ \propto $ \textbf{Коммивояжёр}.
Для этого предъявим полиномиальный по времени алгоритм, который по графу $ G = (V, E) $ строит исходные данные $ C, d_{ij} $ и $ B $ с требуемыми свойствами.
$$ C = V, \qquad B = n, \qquad d_{ij} =
\begin{cases}
	1, \quad \text{ если } \set{v_i, v_j} \in E, \\
	2, \qquad \text{ иначе}
\end{cases} $$
В графе есть гамильтонов цикл тогда и только тогда, когда маршрут проходит теми городами, расстояния между которыми равно 1.

\begin{definition}
	Задача $ Z_1 $ \emph{полиномиально эквивалентна} задаче $ Z_2 $, если $ Z_1 \propto Z_2 $ и $ Z_2 \propto Z_1 $.
\end{definition}

\begin{notation}
	$ Z_1 \sim_p Z_2 $
\end{notation}

\begin{theorem}
	Отношение полиномиальной эквивалентности является отношением эквивалентности.
\end{theorem}

Отношение $ \sim_p $ разбивает класс \textbf{NP} на классы эквивалентности.
Один из них "--- класс \textbf{P}.

\subsection{NP-полные задачи}

\begin{definition}
	Задача $ Z $ называется \emph{NP-полной}, если она сама принадлежит классу \textbf{NP}, и любая другая из класса \textbf{NP} полиномиально сводится к ней.
\end{definition}

\begin{theorem}
	Класс NP-полных задач образует класс эквивалентности в классе \textbf{NP}.
\end{theorem}

Если в определении NP-полной задачи убрать требование её принадлежности классу \textbf{NP}, то получим определение \emph{NP-трудной} задачи.

\subsection{Задача Выполнимость}

Первым примером NP-полной задачи является следующая задача.

\begin{problem}[Выполнимость]
	\textbf{Дано:} $ U = \set{u_1, \dots, u_n} $ "--- множество пропозициональных переменных, $ C = \set{c_1, \dots, c_m} $ "--- множество предложений над $ U $.

	\textbf{Вопрос:} выполнимо ли множество $ C $, \ie существует ли набор значений переменных из $ U $, для которого истинны все предложения из $ C $?
	$$ \exists u_1, \dots, u_n~(c_1 \amp \dots \amp c_m) $$
\end{problem}
