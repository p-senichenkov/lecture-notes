\part{Транзакции}

\section{Определение и основные свойства транзакций}

\begin{definition}
	\emph{Транзакция} "--- это последовательность операций, производимых над базой данных и переводящих её из одного согласованного состояния в другое согласованное состояние.
\end{definition}

Требования ACID:
\begin{itemize}
	\item Atomicity:

		Каждая транзакция представляет собой единицу работы.
		Она не может быть разбита на меньшие части.
		Выполняются либо все действия, определённые в данной транзакции, либо не выполняется ни одно из них.
	\item Consistency:

		Гарантируется, что по мере выполнения транзакций данные переходят из одного согласованного состояния в другое "--- транзакция не разрушает взаимной согласованности данных.
		Для поддержания согласованности данных в процессе транзакции применяются правила, проверки, ограничения и триггеры.
	\item Isolation:

		Конкурирующие за доступ к БД транзакции физически обрабатываются изолированно друг от друга, но для пользователей это выглядит так, как будто они выполняются параллельно.
	\item Durability:

		Если транзакция завершена успешно, то те изменения данных, которые ей произведены не могут быть потеряны ни при каких обстоятельствах.
\end{itemize}

\begin{definition}
	База данных находится в \emph{согласованном состоянии}, если для этого состояния выполнены все ограничения целостности.
\end{definition}

\begin{definition}
	\emph{Ограничение целостности} "--- это некоторое утверждение, которое может быть истинным или ложным в зависимости от состояния базы данных.
\end{definition}

\section{Аномалии конкурентного выполнения транзакций}

Аномалии конкурентного доступа:
\begin{itemize}
	\item потерянное обновление (lost update): \\
		\begin{tabular}{c | c}
			\mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} & \mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} \\
			\mintinline{SQL}{UPDATE t1 SET f2 = 20 WHERE f1 = 1;} & \\
															  & \mintinline{SQL}{UPDATE tbl1 SET f2 = 25 WHERE f1 = 1;}
		\end{tabular}
	\item ``грязное'' чтение (dirty read): \\
		\begin{tabular}{c | c}
			\mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} & \\
			\mintinline{SQL}{UPDATE t1 SET f2 = f2 + 1 WHERE f1 = 1;} & \\
																	  & \mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} \\
			\mintinline{SQL}{ROLLBACK WORK;}
		\end{tabular}
	\item неповторяющееся чтение (non-repeatable read): \\
		\begin{tabular}{c | c}
			\mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} & \mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;} \\
			\mintinline{SQL}{UPDATE t1 SET f2 = f2 + 1 WHERE f1 = 1;} & \\
			\mintinline{SQL}{COMMIT;} & \\
									  & \mintinline{SQL}{SELECT f2 FROM t1 WHERE f1 = 1;}
		\end{tabular}
	\item фантомное чтение (phantom read): \\
		\begin{tabular}{c | c}
			& \mintinline{SQL}{SELECT SUM(f2) FROM t1;} \\
			\mintinline{SQL}{INSERT INTO t1 (f1, f2) VALUES (15, 20)} & \\
																	  & \mintinline{SQL}{SELECT SUM(f2) FROM t1;}
		\end{tabular}
\end{itemize}

\section{Конфликты и эквивалентность расписаний по конфликтам. Сериализуемость}

\begin{definition}
	\emph{Конфликт} "--- пара операций из расписания такая, что
	\begin{itemize}
		\item операции принадлежат разным транзакциям;
		\item они работают с одним элементом данных;
		\item по крайней мере одна из двух "--- операция записи.
	\end{itemize}
\end{definition}

\begin{definition}
	Расписания \emph{эквивалентны}, если из множества конфликтов совпадают.
\end{definition}

\begin{definition}
	Расписание называется \emph{серийным}, если все операции одной транзакции либо предшествуют, либо следуют за операциями любой другой транзакции.
\end{definition}

\begin{definition}
	Расписание называется \emph{сериализуемым} (по конфликтам), если оно эквивалентно серийному.
\end{definition}

\begin{definition}
	Считаем, что любые операции чтения коммутируют и любые операции над разными элементами коммутируют.
	Расписание \emph{сериализуемо} (по коммутативности), если его можно преобразовать в серийное перестановками соседних операций.
\end{definition}

\section{Использование замков: двухфазный протокол блокирования}

Замки для одного элемента данных несовместимы, если они устанавливаются разными транзакциями и по крайней мере один из них на запись.
Попытка установить несовместимый замок переводит транзакцию в состояние ожидания.

Протокол блокирования 2PL:
\begin{itemize}
	\item для каждой операции необходимо предварительно установить замок, все замки должны быть сняты до завершения транзакции;
	\item транзакция не может устанавливать новые замки после того, как она сняла какой-то из замков.
\end{itemize}
Двухфазный протокол генерирует расписания, сериализуемые по конфликтам.

\section{Тупики: обнаружение и разрешение}

Транзакции, попавшие в тупик должны быть оборваны.

Для обнаружения тупиков строится \emph{граф ожиданий}:
\begin{itemize}
	\item вершины "--- активные транзакции;
	\item дуги проводятся из ожидающей транзакции в транзакцию, установившую несовместимые замки.
\end{itemize}

Тупик имеет место тогда и только тогда, когда в графе ожиданий есть контур.

\section{Протокол установки замков для дерева}

Пусть БД структурирована как дерево.
Тогда можно применить протокол WTL (Write-only tree locking):
\begin{itemize}
	\item все замки "--- на запись;
	\item для установки замка необходимо иметь установленный замок на родительскую вершину;
	\item ни один элемент не блокируется одной и той же транзакцией дважды;
	\item снятие замков возможно в любое время и не препятствует установке новых замков.
\end{itemize}

\begin{stmts}
	\item граф сериализуемости ацикличен;
	\item транзакции сериализуются в том порядке, в котором они устанавливают замки на корень;
	\item протокол WTL свободен от тупиков.
\end{stmts}

\section{Уровни изоляции транзакций}

\begin{minted}{SQL}
	SET TRANSACTION ISOLATION LEVEL
		{READ UNCOMMITED | READ COMMITED | REPEATABLE READ | SERIALIZABLE}
		{READ WRITE | READ ONLY} [NOT] DEFERRABLE;
\end{minted}

Уровни изоляции:
\begin{enumerate}
	\item \texttt{READ UNCOMMITTED}:
		\begin{itemize}
			\item не устанавливаются блокировки на чтение;
			\item транзакция может считывать изменённые другими транзакциями, но не зафиксированные строки, \ie можно читать "грязные" данные;
			\item значения в данных могут быть изменены и до окончания транзакции строки могут появляться и исчезать в наборе данных.
		\end{itemize}
	\item \texttt{READ COMMITTED}:
		\begin{itemize}
			\item нельзя считывать данные, которые были изменены другими транзакциями, но ещё не были зафиксированы;
			\item считанные данные могут быть изменены другими транзакциями во время работы текущей транзакции.
		\end{itemize}
	\item \texttt{REPEATABLE READ}:
		\begin{itemize}
			\item нельзя считывать незафиксированные данные;
			\item совмещаемые блокировки применяются ко всем считываемым данным и сохраняются до завершения; это запрещает другим транзакциям изменять строки, считанные данной транзакцией;
			\item другие транзакции могут вставлять новые строки, соответствующие условиям поиска текущей транзакции.
		\end{itemize}
	\item \texttt{SERIALIZABLE}:
		\begin{itemize}
			\item нельзя считывать незафиксированные данные;
			\item другие транзакции не могут изменять данные, считанные текущей транзакцией;
			\item другие транзакции не могут вставлять новые строки, удовлетворяющие условиям поиска текущей транзакции; при повторном считывании будет тот же самый набор строк.
		\end{itemize}
\end{enumerate}

\section{Фазы транзакций. Обрывы транзакций}

\begin{enumerate}
	\item установка уровня изоляции;
	\item начало
		\begin{minted}{SQL}
			BEGIN TRANSACTION
		\end{minted}
	\item конец
		\begin{minted}{SQL}
			COMMIT
			ROLLBACK
		\end{minted}
\end{enumerate}

\section{Защита от отказов системы: правила ведения журнала}

\begin{definition}
	\emph{Журнал транзакций} "--- это часть БД, в которую поступают данные обо всех изменениях всех объектов БД.
	Журнал недоступен пользователям СУБД и поддерживается особо тщательно.
	Форма записи в журнал зависит от СУБД.
	Обычно там фиксируется:
	\begin{itemize}
		\item номер транзакции;
		\item состояние транзакции (завершена фиксацией или откатом, не завершена, ожидает);
		\item точки сохранения;
		\item команды, составляющие транзакцию.
	\end{itemize}
\end{definition}

Правила ведения журнала:
\begin{itemize}
	\item журнал ведётся последовательно;
	\item запись происходит до самих действий (write-ahead log);
	\item регистрируются операции записи, начала и конца транзакции;
	\item каждая запись содержит данные отката (redo) и ``наката'' (redo);
	\item при фиксации запись журнала обязательно ``выталкивается'' на диск.
\end{itemize}

\section{Ведение журнала: контрольные точки}

Savepoint запоминает промежуточную ``текущую копию'' состояния базы данных для того, чтобы при необходимости можно было вернуться к состоянию БД в точке сохранения: откатить работу от текущего момента до точки сохранения (\texttt{ROLLBACK TO sp}) или зафиксировать работу от начала транзакции до точки сохранения (\texttt{COMMIT TO sp}).
На одну транзакцию может быть несколько точек сохранения.

\begin{minted}{SQL}
	SAVE {TRAN | TRANSACTION} sp_name;
\end{minted}

\section{Технологии клиент\tpst{"--~}{--}сервер: подходы}

Роли клиента и сервера выполняются на разных системах.
Различают ``толстые'' и ``тонкие'' клиенты.

\begin{figure}[!ht]
	\centering
	\begin{subfigure}{0.9\textwidth}
		\centering
		\begin{tikzpicture}[>=Stealth]
			\draw (-6.5, -1) rectangle (-1, 1);
			\node at (-3.75, -0.75) {Клиент};
			\node [thin, draw=black!50, text width=2.55cm] at (-5, 0.25) {Компонент представления};
			\node [thin, draw=black!50, text width=2cm] at (-2.3, 0.25) {Прикладной компонент};

			\draw[->] (-0.5, 0.5) -- (0.5, 0.5);
			\node at (0, 0) {Файлы};
			\draw[->] (0.5, -0.5) -- (-0.5, -0.5);

			\draw (1, -1) rectangle (4, 1);
			\node at (2.5, -0.75) {Сервер};
			\node [thin, draw=black!50, text width=2cm] at (2.5, 0.25) {Компонент доступа к ресурсам};
		\end{tikzpicture}
		\caption{FS}
	\end{subfigure}
	\begin{subfigure}{0.9\textwidth}
		\centering
		\begin{tikzpicture}[>=Stealth]
			\draw (-6.5, -1) rectangle (-1, 1);
			\node at (-3.75, -0.75) {Клиент};
			\node [thin, draw=black!50, text width=2.55cm] at (-5, 0.25) {Компонент представления};
			\node [thin, draw=black!50, text width=2cm] at (-2.3, 0.25) {Прикладной компонент};

			\node at (0, 0.5) [above] {SQL};
			\draw[->] (-0.5, 0.5) -- (0.5, 0.5);
			\node at (0, -0.5) [above] {Данные};
			\draw[->] (0.5, -0.5) -- (-0.5, -0.5);

			\draw (1, -1) rectangle (4, 1);
			\node at (2.5, -0.75) {Сервер};
			\node [thin, draw=black!50, text width=2cm] at (2.5, 0.25) {Компонент доступа к ресурсам};
		\end{tikzpicture}
		\caption{RDA}
	\end{subfigure}
	\begin{subfigure}{0.9\textwidth}
		\centering
		\begin{tikzpicture}[>=Stealth]
			\draw (-4, -1) rectangle (-1, 1);
			\node at (-2.5, -0.75) {Клиент};
			\node [thin, draw=black!50, text width=2.55cm] at (-2.5, 0.25) {Компонент представления};

			\node at (0, 0.5) [above] {Вызов};
			\draw[->] (-0.5, 0.5) -- (0.5, 0.5);
			\node at (0, -0.5) [above] {Данные};
			\draw[->] (0.5, -0.5) -- (-0.5, -0.5);

			\draw (1, -1) rectangle (6.5, 1);
			\node at (3.75, -0.75) {Сервер};
			\node [thin, draw=black!50, text width=2cm] at (2.3, 0.25) {Прикладной компонент};
			\node [thin, draw=black!50, text width=2cm] at (5, 0.25) {Компонент доступа к ресурсам};
		\end{tikzpicture}
		\caption{DBS}
	\end{subfigure}
	\begin{subfigure}{0.9\textwidth}
		\centering
		\begin{tikzpicture}[>=Stealth]
			\draw (-4, -1) rectangle (-1, 1);
			\node at (-2.5, -0.75) {Клиент};
			\node [thin, draw=black!50, text width=2.55cm] at (-2.5, 0.25) {Компонент представления};

			\draw[->] (-0.8, 0.5) -- (-0.2, 0.5);
			\node at (-0.5, 0) {API};
			\draw[->] (-0.8, -0.5) -- (-0.2, -0.5);

			\draw (0, -1) rectangle (2.5, 1);
			\node at (1.25, -1) [above] {Сервер};
			\node [thin, draw=black!50, text width=2cm] at (1.25, 0.25) {Прикладной компонент};

			\draw[->] (2.7, 0.5) -- (3.3, 0.5);
			\draw[->] (3.3, -0.5) -- (2.7, -0.5);

			\draw (3.5, -1) rectangle (6.5, 1);
			\node at (5, -0.75) {Сервер};
			\node [thin, draw=black!50, text width=2cm] at (5, 0.25) {Компонент доступа к ресурсам};
		\end{tikzpicture}
		\caption{AS}
	\end{subfigure}
	\caption{Подходы к клиент"--~серверной модели.}
	\label{pic:client-serv}
\end{figure}

Выделяют четыре подхода к клиент"--~серверной модели (\autoref{pic:client-serv}):
\begin{itemize}
	\item Файловый сервер (File Server):
		\begin{itemize}
			\item файловый сервер хранит файлы, предоставляя к ним доступ пользователям сети;
			\item всё программное обеспечение ИС располагается на сетевых компьютерах;
			\item для выполнения операций с данными необходимо получить их копию на сетевой компьютер;
			\item недостатки:
				\begin{itemize}
					\item высокий трафик;
					\item узкий спектр операций манипуляций с данными;
					\item отсутствие адекватных средств безопасности доступа к данным.
				\end{itemize}
		\end{itemize}
	\item Доступ к удалённым данным (Remote Access Data):
		\begin{itemize}
			\item унификация интерфейса ``клиент"--~сервер'' в виде языка SQL;
			\item перенос компонента представления и прикладного компонента на клиенты существенно разгружает сервер БД;
			\item администрирование приложений практически невозможно из-за совмещения в одной программе различных функций.
		\end{itemize}
	\item Сервер базы данных (DataBase Server):
		\begin{itemize}
			\item основа "--- механизм хранимых процедур. Процедуры хранятся в словаре базы данных, разделяются между несколькими клиентами и выполняются на сервере;
			\item достоинства:
				\begin{itemize}
					\item возможность централизованного администрирования прикладных функций;
					\item снижение трафика (вместо SQL-запросов по сети направляются вызовы процедур);
					\item возможность разделения процедуры между несколькими приложениями;
					\item экономия ресурсов сервера за счёт использования единожды созданного плана выполнения процедуры.
				\end{itemize}
			\item недостатки:
				\begin{itemize}
					\item ограниченность средств, используемых для написания процедур;
					\item сфера их использования ограничена конкретной СУБД;
					\item не во всех СУБД есть возможность отладки и тестирования хранимых процедур.
				\end{itemize}
			\item обычно используется модель RDA+DSB;
		\end{itemize}
	\item Сервер приложений (Application Server):
		\begin{itemize}
			\item специфические функции приложений выделятся на отдельный сервер "--- \emph{сервер приложений};
			\item достоинства:
				\begin{itemize}
					\item существует большое количество компонентов;
					\item массовое использование в относительно простых системах;
					\item средства генерации кода.
				\end{itemize}
			\item недостатки:
				\begin{itemize}
					\item неэффективное использование серверов данных;
					\item слишком большое количество сетевых обменов;
					\item искусственное привязывание ролей к слоям.
				\end{itemize}
		\end{itemize}
\end{itemize}
