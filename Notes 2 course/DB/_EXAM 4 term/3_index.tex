\part{Индексы}

\section{Кластеризованные таблицы и индексы}

Файлы конфигурации и файлы данных, используемые кластером базы данных, традиционно хранятся вместе в каталоге данных кластера, который обычно называют PGDATA.

Для каждой БД в кластере существует подкаталог внутри PGDATA/base, названный по OID базы в pg\textunderscore database.
Этот подкаталог по-умолчанию является местом хранения файлов базы данных.

Каждая таблица и индекс хранятся в отдельном файле.
Для каждой таблицы и индекса есть карта свободного пространства.
Когда объём таблицы или индекса превышает заданный размер, она делится на сегменты (ноды).

Основной единицей хранения данных является страница.
Место на диске для размещения файла данных в БД логически разделяется на страницы с непрерывной нумерацией.
Дисковые операции ввода-вывода осуществляются на уровне страницы.
СУБД считывает или записывает целые страницы данных.

\emph{Кластерный индекс} использует возможность физического индексирования данных.
В результате будут отсортированы данные в самой таблице согласно порядку этого индекса.
Добавление информации в таблицу приводит к изменению физического порядка данных.
Кластерным может быть только один индекс в таблице.

Кластерный индекс обеспечивает самый быстрый поиск по заданному ключу.

\section{Первичные и вторичные индексы. Плотные и неплотные индексы}

На таблице можно определить до 249 некластерных индексов.
В таком случае кластерный индекс становится \emph{первичным}, а все некластерные "--- \emph{вторичными}.

\comment{Если верить википедии, то} \emph{плотный} индекс ссылается на запись в таблице, а \emph{неплотный} "--- на блок данных.

\section{Индексы: B-дерево}

\begin{itemize}
	\item упорядочиваем таблицу по значению ключа;
	\item для каждого блока данных определяем минимальное значение ключа и адрес;
	\item эти пары также размещаем в блоках;
	\item наращиваем уровни, пока не появится уровень из одного блока.
\end{itemize}

\section{Индексы: отфильтрованные, покрывающие, составной ключ}

\subsection*{Покрывающие индексы}

\begin{definition}
	Если все столбцы запроса входят в состав ключа в индексе, то такой индекс называется \emph{покрывающим}.
\end{definition}

Покрывающие индексы могут повысить производительность запросов, так как данные, необходимые для удовлетворения требований запроса, присутствуют в самом индексе "--- не требует считывания страниц данных.

\subsection*{Отфильтрованные индексы}

\begin{definition}
	\emph{Отфильтрованный индекс} "--- некластеризованный индекс, построенный по некоторому подмножеству значений ключа.
\end{definition}

Может повысить производительность запросов, снизить затраты на обслуживание и хранение индексов по сравнению с полнотабличными индексами.
Фильтрованные индексы полезны на больших таблицах.

\subsection*{Составной ключ}

Индекс может быть создан на основании нескольких ключей.
В состав одного составного индекса может входить до 16 столбцов.
Все столбцы ключа составного индекса должны находится в одной таблице или одном и том же представлении.

\section{Индексы: полнотекстовые}

\begin{definition}
	\emph{Полнотекстовый индекс} представляет собой словарь, в котором для каждого слова указано, где оно встречается.
\end{definition}

Процесс построения полнотекстового индекса:
\begin{enumerate}
	\item фильтрация;
	\item разбиение по словам;
	\item удаление стоп-слов;
	\item иногда применяется \emph{стемминг} (выделение основы слова) или \emph{лемматизация} (приведение слова к нормальной форме);
	\item преобразование конвертированных данных в инвертированный список слов;
	\item заполнение полнотекстового индекса.
\end{enumerate}

Заполнение индекса значениями:
\begin{itemize}
	\item \texttt{MANUAL}
		\begin{minted}{SQL}
			ALTER FULLTEXT INDEX ON customers START FULL POPULATION
		\end{minted}
	\item \texttt{AUTO} (не обязательно мгновенно)
\end{itemize}

По-умолчанию индекс сопоставляется с системным стоп-листом.
\begin{minted}{SQL}
	ALTER FULLTEXT INDEX ON table_1 SET STOPLIST = sl
\end{minted}

Запросы с полнотекстовым индексом используют предикаты \texttt{CONTAINS} и \texttt{FREETEXT} и функции \texttt{CONTAINS"-TABLE} и \texttt{FREETEXTTABLE}:
\begin{minted}{SQL}
	SELECT * FROM prod.prod_desc WHERE FREETEXT(desc, 'bike');
	SELECT * FROM prod.prod_desc WHERE CONTAINS(desc, 'bike');
\end{minted}

\texttt{CONTAINS} определяет точное или неточное совпадение, расстояние между словами или взвешенные совпадения.
\texttt{FULLTEXT} используется для поиска значений, которые соответствуют условию по смыслу на основе тезауруса.

\section{Индексы: хеширование}

В памяти хранится стандартная хеш-таблица для ключевого столбца.

\begin{minted}{SQL}
	CREATE INDEX idx_name USING HASH ON t_name (col_name);
\end{minted}

Недостатки хеш-индексов:
\begin{itemize}
	\item хеш-таблица может быть слишком велика;
	\item если в один участок попало слишком много записей, придётся выделять дополнительный блок;
	\item неравномерность размещения записей, возникновение коллизий.
\end{itemize}
\comment{Тут я не согласен: на мой взгляд, это не проблемы, а задачи.}

Хеш-индекс подходит для поиска только по равенству и не поддерживает транзакции.
Хеш-индекс автоматически создаётся при \texttt{JOIN} при отсутствии других индексов.

\section{Индексы: битовые шкалы}

Для каждого значения индексируемого столбца в индекс на основе битовых карт входит одна строка, состоящая из значения столбца и битовой последовательности.
Битовая последовательность имеет длину по количеству строк таблицы, в которой 1 означает, что в данной строке атрибут принимает заданное значение.

\section{Индексы: R-дерево}

R-дерево используется для геометрических и пространственных типов данных.

Для его построения каждая фигура окружается ограничивающим прямоугольником. Дальше принцип тот же, что и в B-дереве.

К недостаткам можно отнести то, что не всегда удаётся избежать перекрытий.
В результате при поиске приходится просматривать несколько веток.

Возможные критерии разделения узла:
\begin{itemize}
	\item минимальная площадь;
	\item минимальное перекрытие;
	\item минимальные границы.
\end{itemize}
